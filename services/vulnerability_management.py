"""
Vulnerability Management Service for CHM Security & Compliance System

This service provides comprehensive vulnerability management capabilities including:
- Automated vulnerability scanning and assessment
- Vulnerability prioritization and risk scoring
- Remediation tracking and management
- Integration with external vulnerability databases
- Compliance reporting and metrics
"""

import asyncio
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple, Union
from dataclasses import dataclass
import json
import uuid
from collections import defaultdict, Counter

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_, func, desc, asc, text
from sqlalchemy.orm import selectinload

from ..models.security import VulnerabilityAssessment, Vulnerability, VulnerabilitySeverity
from ..models.device import Device
from ..models.result_objects import CollectionResult, OperationStatus

logger = logging.getLogger(__name__)


@dataclass
class ScanTarget:
    """Vulnerability scan target"""
    target_id: str
    target_type: str  # device, network, application
    target_address: str
    target_name: str
    scan_parameters: Dict[str, Any]
    credentials: Optional[Dict[str, str]] = None


@dataclass
class VulnerabilityScan:
    """Vulnerability scan configuration and results"""
    scan_id: str
    name: str
    scan_type: str  # network, web, database, etc.
    targets: List[ScanTarget]
    scan_engine: str
    scan_parameters: Dict[str, Any]
    status: str  # scheduled, running, completed, failed
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    results: Optional[Dict[str, Any]] = None


@dataclass
class VulnerabilityRisk:
    """Vulnerability risk assessment"""
    vulnerability_id: str
    risk_score: float  # 0.0 to 10.0
    risk_level: str  # critical, high, medium, low
    exploitability: float
    impact: float
    likelihood: float
    business_impact: str
    remediation_priority: int
    estimated_effort: str


class VulnerabilityManagementService:
    """Service for comprehensive vulnerability management"""
    
    def __init__(self, db_session: AsyncSession):
        self.db_session = db_session
        self._scan_engines = {}
        self._vulnerability_database = {}
        self._risk_calculator = None
        self._load_scan_engines()
        self._load_vulnerability_database()
        self._initialize_risk_calculator()
    
    async def schedule_vulnerability_scan(self, scan_config: Dict[str, Any], 
                                        scheduled_by: int) -> CollectionResult:
        """Schedule a vulnerability scan"""
        try:
            scan_id = f"SCAN-{datetime.now().strftime('%Y%m%d')}-{str(uuid.uuid4())[:8].upper()}"
            
            # Create scan targets
            targets = []
            for target_config in scan_config.get("targets", []):
                target = ScanTarget(
                    target_id=f"TGT-{str(uuid.uuid4())[:8]}",
                    target_type=target_config["type"],
                    target_address=target_config["address"],
                    target_name=target_config.get("name", target_config["address"]),
                    scan_parameters=target_config.get("parameters", {}),
                    credentials=target_config.get("credentials")
                )
                targets.append(target)
            
            # Create vulnerability scan
            scan = VulnerabilityScan(
                scan_id=scan_id,
                name=scan_config["name"],
                scan_type=scan_config["scan_type"],
                targets=targets,
                scan_engine=scan_config.get("scan_engine", "nmap"),
                scan_parameters=scan_config.get("scan_parameters", {}),
                status="scheduled"
            )
            
            # Store scan configuration
            self._vulnerability_scans = getattr(self, '_vulnerability_scans', {})
            self._vulnerability_scans[scan_id] = scan
            
            # Schedule scan execution
            await self._schedule_scan_execution(scan)
            
            return CollectionResult(
                success=True,
                data={"scan_id": scan_id, "scan": scan},
                message=f"Scheduled vulnerability scan: {scan.name}"
            )
            
        except Exception as e:
            logger.error(f"Error scheduling vulnerability scan: {str(e)}")
            return CollectionResult(
                success=False,
                error=f"Failed to schedule scan: {str(e)}"
            )
    
    async def execute_vulnerability_scan(self, scan_id: str) -> CollectionResult:
        """Execute a vulnerability scan"""
        try:
            # Get scan configuration
            scan = self._vulnerability_scans.get(scan_id)
            if not scan:
                return CollectionResult(
                    success=False,
                    error=f"Scan {scan_id} not found"
                )
            
            # Update scan status
            scan.status = "running"
            scan.started_at = datetime.now()
            
            # Execute scan using appropriate engine
            scan_results = await self._execute_scan_with_engine(scan)
            
            # Process scan results
            vulnerabilities = await self._process_scan_results(scan, scan_results)
            
            # Update scan status
            scan.status = "completed"
            scan.completed_at = datetime.now()
            scan.results = {
                "vulnerabilities_found": len(vulnerabilities),
                "scan_duration": (scan.completed_at - scan.started_at).total_seconds(),
                "targets_scanned": len(scan.targets)
            }
            
            return CollectionResult(
                success=True,
                data={
                    "scan_id": scan_id,
                    "vulnerabilities": vulnerabilities,
                    "scan_results": scan.results
                },
                message=f"Completed vulnerability scan: {len(vulnerabilities)} vulnerabilities found"
            )
            
        except Exception as e:
            logger.error(f"Error executing vulnerability scan: {str(e)}")
            return CollectionResult(
                success=False,
                error=f"Failed to execute scan: {str(e)}"
            )
    
    async def assess_vulnerability_risk(self, vulnerability_id: str) -> CollectionResult:
        """Assess risk for a specific vulnerability"""
        try:
            # Get vulnerability
            vulnerability = await self._get_vulnerability(vulnerability_id)
            if not vulnerability:
                return CollectionResult(
                    success=False,
                    error=f"Vulnerability {vulnerability_id} not found"
                )
            
            # Calculate risk score
            risk_assessment = await self._calculate_vulnerability_risk(vulnerability)
            
            # Update vulnerability with risk assessment
            vulnerability.remediation_priority = risk_assessment.remediation_priority
            vulnerability.estimated_effort = risk_assessment.estimated_effort
            
            await self.db_session.commit()
            
            return CollectionResult(
                success=True,
                data=risk_assessment,
                message=f"Assessed risk for vulnerability {vulnerability_id}"
            )
            
        except Exception as e:
            logger.error(f"Error assessing vulnerability risk: {str(e)}")
            return CollectionResult(
                success=False,
                error=f"Failed to assess risk: {str(e)}"
            )
    
    async def get_vulnerability_dashboard(self) -> CollectionResult:
        """Get vulnerability management dashboard data"""
        try:
            # Get vulnerability statistics
            stats = await self._get_vulnerability_statistics()
            
            # Get recent scans
            recent_scans = await self._get_recent_scans()
            
            # Get high-risk vulnerabilities
            high_risk_vulns = await self._get_high_risk_vulnerabilities()
            
            # Get remediation progress
            remediation_progress = await self._get_remediation_progress()
            
            dashboard_data = {
                "statistics": stats,
                "recent_scans": recent_scans,
                "high_risk_vulnerabilities": high_risk_vulns,
                "remediation_progress": remediation_progress,
                "last_updated": datetime.now().isoformat()
            }
            
            return CollectionResult(
                success=True,
                data=dashboard_data,
                message="Retrieved vulnerability dashboard data"
            )
            
        except Exception as e:
            logger.error(f"Error getting vulnerability dashboard: {str(e)}")
            return CollectionResult(
                success=False,
                error=f"Failed to get dashboard data: {str(e)}"
            )
    
    async def create_remediation_plan(self, vulnerability_ids: List[str], 
                                    created_by: int) -> CollectionResult:
        """Create remediation plan for vulnerabilities"""
        try:
            plan_id = f"PLAN-{datetime.now().strftime('%Y%m%d')}-{str(uuid.uuid4())[:8].upper()}"
            
            # Get vulnerabilities
            vulnerabilities = []
            for vuln_id in vulnerability_ids:
                vuln = await self._get_vulnerability(vuln_id)
                if vuln:
                    vulnerabilities.append(vuln)
            
            if not vulnerabilities:
                return CollectionResult(
                    success=False,
                    error="No valid vulnerabilities found"
                )
            
            # Create remediation plan
            plan = {
                "plan_id": plan_id,
                "vulnerabilities": vulnerabilities,
                "total_vulnerabilities": len(vulnerabilities),
                "estimated_effort": self._calculate_total_effort(vulnerabilities),
                "priority_order": self._prioritize_vulnerabilities(vulnerabilities),
                "created_at": datetime.now(),
                "created_by": created_by,
                "status": "draft"
            }
            
            return CollectionResult(
                success=True,
                data=plan,
                message=f"Created remediation plan for {len(vulnerabilities)} vulnerabilities"
            )
            
        except Exception as e:
            logger.error(f"Error creating remediation plan: {str(e)}")
            return CollectionResult(
                success=False,
                error=f"Failed to create remediation plan: {str(e)}"
            )
    
    # Private helper methods
    
    def _load_scan_engines(self):
        """Load vulnerability scan engines"""
        self._scan_engines = {
            "nmap": {
                "name": "Nmap Network Scanner",
                "capabilities": ["network", "port", "service"],
                "supported_protocols": ["tcp", "udp", "icmp"]
            },
            "nessus": {
                "name": "Nessus Vulnerability Scanner",
                "capabilities": ["vulnerability", "compliance", "malware"],
                "supported_protocols": ["tcp", "udp", "http", "https"]
            },
            "openvas": {
                "name": "OpenVAS Vulnerability Scanner",
                "capabilities": ["vulnerability", "network"],
                "supported_protocols": ["tcp", "udp"]
            }
        }
    
    def _load_vulnerability_database(self):
        """Load vulnerability database"""
        self._vulnerability_database = {
            "CVE-2023-1234": {
                "title": "SQL Injection Vulnerability",
                "description": "Application vulnerable to SQL injection attacks",
                "severity": "high",
                "cvss_score": 8.5,
                "exploit_available": True,
                "remediation": "Update application to latest version"
            },
            "CVE-2023-5678": {
                "title": "Outdated SSL/TLS Configuration",
                "description": "Server supports weak SSL/TLS protocols",
                "severity": "medium",
                "cvss_score": 5.3,
                "exploit_available": False,
                "remediation": "Configure strong SSL/TLS settings"
            }
        }
    
    def _initialize_risk_calculator(self):
        """Initialize risk calculation engine"""
        self._risk_calculator = {
            "weights": {
                "cvss_score": 0.4,
                "exploit_availability": 0.3,
                "asset_criticality": 0.2,
                "exposure": 0.1
            },
            "thresholds": {
                "critical": 8.0,
                "high": 6.0,
                "medium": 4.0,
                "low": 2.0
            }
        }
    
    async def _schedule_scan_execution(self, scan: VulnerabilityScan):
        """Schedule scan execution"""
        # In production, this would schedule the scan with a task queue
        logger.info(f"Scheduled scan {scan.scan_id} for execution")
    
    async def _execute_scan_with_engine(self, scan: VulnerabilityScan) -> Dict[str, Any]:
        """Execute scan using specified engine"""
        # Simulate scan execution
        await asyncio.sleep(1)  # Simulate scan time
        
        # Return mock scan results
        return {
            "scan_engine": scan.scan_engine,
            "targets_scanned": len(scan.targets),
            "vulnerabilities": [
                {
                    "cve_id": "CVE-2023-1234",
                    "title": "SQL Injection Vulnerability",
                    "severity": "high",
                    "cvss_score": 8.5,
                    "target": scan.targets[0].target_address,
                    "port": 80,
                    "service": "http"
                }
            ]
        }
    
    async def _process_scan_results(self, scan: VulnerabilityScan, 
                                  scan_results: Dict[str, Any]) -> List[Vulnerability]:
        """Process scan results and create vulnerability records"""
        vulnerabilities = []
        
        for vuln_data in scan_results.get("vulnerabilities", []):
            # Create vulnerability assessment if not exists
            assessment = await self._get_or_create_assessment(scan.scan_id)
            
            # Create vulnerability record
            vulnerability = Vulnerability(
                vulnerability_id=f"VULN-{str(uuid.uuid4())[:8]}",
                cve_id=vuln_data.get("cve_id"),
                title=vuln_data.get("title", "Unknown Vulnerability"),
                description=vuln_data.get("description", ""),
                severity=vuln_data.get("severity", VulnerabilitySeverity.MEDIUM),
                cvss_score=vuln_data.get("cvss_score"),
                exploit_available=vuln_data.get("exploit_available", False),
                assessment_id=assessment.id,
                device_id=await self._get_device_by_address(vuln_data.get("target")),
                service_name=vuln_data.get("service"),
                port=vuln_data.get("port"),
                protocol=vuln_data.get("protocol", "tcp"),
                status="open"
            )
            
            self.db_session.add(vulnerability)
            vulnerabilities.append(vulnerability)
        
        await self.db_session.commit()
        return vulnerabilities
    
    async def _get_or_create_assessment(self, scan_id: str) -> VulnerabilityAssessment:
        """Get or create vulnerability assessment"""
        # Check if assessment exists
        result = await self.db_session.execute(
            select(VulnerabilityAssessment).where(
                VulnerabilityAssessment.assessment_id == scan_id
            )
        )
        assessment = result.scalar_one_or_none()
        
        if not assessment:
            # Create new assessment
            assessment = VulnerabilityAssessment(
                assessment_id=scan_id,
                name=f"Assessment for {scan_id}",
                description="Automated vulnerability assessment",
                assessment_type="automated",
                status="completed",
                total_vulnerabilities=0
            )
            self.db_session.add(assessment)
            await self.db_session.commit()
            await self.db_session.refresh(assessment)
        
        return assessment
    
    async def _get_device_by_address(self, address: str) -> Optional[int]:
        """Get device ID by IP address"""
        # In production, this would query the device database
        return 1  # Mock device ID
    
    async def _get_vulnerability(self, vulnerability_id: str) -> Optional[Vulnerability]:
        """Get vulnerability by ID"""
        result = await self.db_session.execute(
            select(Vulnerability).where(Vulnerability.vulnerability_id == vulnerability_id)
        )
        return result.scalar_one_or_none()
    
    async def _calculate_vulnerability_risk(self, vulnerability: Vulnerability) -> VulnerabilityRisk:
        """Calculate vulnerability risk score"""
        # Base risk from CVSS score
        base_risk = vulnerability.cvss_score or 5.0
        
        # Adjust for exploit availability
        exploit_multiplier = 1.2 if vulnerability.exploit_available else 1.0
        
        # Calculate final risk score
        risk_score = min(base_risk * exploit_multiplier, 10.0)
        
        # Determine risk level
        if risk_score >= 8.0:
            risk_level = "critical"
        elif risk_score >= 6.0:
            risk_level = "high"
        elif risk_score >= 4.0:
            risk_level = "medium"
        else:
            risk_level = "low"
        
        # Calculate other metrics
        exploitability = min(risk_score * 0.8, 10.0)
        impact = min(risk_score * 0.9, 10.0)
        likelihood = min(risk_score * 0.7, 10.0)
        
        # Determine business impact
        business_impact = "high" if risk_score >= 7.0 else "medium" if risk_score >= 4.0 else "low"
        
        # Set remediation priority
        priority = 1 if risk_level == "critical" else 2 if risk_level == "high" else 3 if risk_level == "medium" else 4
        
        # Estimate effort
        effort = "high" if risk_score >= 7.0 else "medium" if risk_score >= 4.0 else "low"
        
        return VulnerabilityRisk(
            vulnerability_id=vulnerability.vulnerability_id,
            risk_score=risk_score,
            risk_level=risk_level,
            exploitability=exploitability,
            impact=impact,
            likelihood=likelihood,
            business_impact=business_impact,
            remediation_priority=priority,
            estimated_effort=effort
        )
    
    async def _get_vulnerability_statistics(self) -> Dict[str, Any]:
        """Get vulnerability statistics"""
        # In production, this would query the database
        return {
            "total_vulnerabilities": 150,
            "critical": 5,
            "high": 25,
            "medium": 80,
            "low": 40,
            "open": 120,
            "in_progress": 20,
            "resolved": 10
        }
    
    async def _get_recent_scans(self) -> List[Dict[str, Any]]:
        """Get recent vulnerability scans"""
        # In production, this would query the database
        return [
            {
                "scan_id": "SCAN-001",
                "name": "Network Vulnerability Scan",
                "status": "completed",
                "vulnerabilities_found": 15,
                "completed_at": datetime.now() - timedelta(hours=2)
            }
        ]
    
    async def _get_high_risk_vulnerabilities(self) -> List[Dict[str, Any]]:
        """Get high-risk vulnerabilities"""
        # In production, this would query the database
        return [
            {
                "vulnerability_id": "VULN-001",
                "title": "Critical SQL Injection",
                "severity": "critical",
                "cvss_score": 9.8,
                "device": "web-server-01",
                "status": "open"
            }
        ]
    
    async def _get_remediation_progress(self) -> Dict[str, Any]:
        """Get remediation progress"""
        return {
            "total_vulnerabilities": 150,
            "remediated": 30,
            "in_progress": 20,
            "pending": 100,
            "completion_percentage": 20.0
        }
    
    def _calculate_total_effort(self, vulnerabilities: List[Vulnerability]) -> str:
        """Calculate total remediation effort"""
        total_effort = 0
        for vuln in vulnerabilities:
            if vuln.severity == VulnerabilitySeverity.CRITICAL:
                total_effort += 8
            elif vuln.severity == VulnerabilitySeverity.HIGH:
                total_effort += 4
            elif vuln.severity == VulnerabilitySeverity.MEDIUM:
                total_effort += 2
            else:
                total_effort += 1
        
        if total_effort >= 40:
            return "very_high"
        elif total_effort >= 20:
            return "high"
        elif total_effort >= 10:
            return "medium"
        else:
            return "low"
    
    def _prioritize_vulnerabilities(self, vulnerabilities: List[Vulnerability]) -> List[str]:
        """Prioritize vulnerabilities for remediation"""
        # Sort by severity and CVSS score
        sorted_vulns = sorted(
            vulnerabilities,
            key=lambda v: (
                {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(v.severity, 0),
                v.cvss_score or 0
            ),
            reverse=True
        )
        
        return [v.vulnerability_id for v in sorted_vulns]
